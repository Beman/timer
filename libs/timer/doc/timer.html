<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Boost System Timers</title>
  <link rel="stylesheet" type="text/css" href=
  "../../../doc/src/minimal.css">
</head>

<body>

<h1><img border="0" src="../../../boost.png" align="center" width="277" height="86"> 
Boost Timer Library Version 2<br>
&nbsp;</h1>
<div align="center">
  <center>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="70%" bgcolor="#CCFFFF">
    <tr>
      <td width="100%">
      <p align="center"><font size="6"><b>This is a major revision of the 
      Version 2 draft</b></font><b><font size="6">!</font></b></p>
      <ul>
        <li>
        <p align="left">The original content of the Boost.Timer library is now 
        deprecated.</li>
        <li>
        <p align="left">The new headers for Boost.Timer are in <code>
        &lt;boost/timer/...&gt;</code></li>
        <li>
        <p align="left">All new content is in namespace <code>boost::timer</code>. </li>
        <li>
        <p align="left">The unit of time has been changed from microseconds to 
        nanoseconds.</li>
        <li>
        <p align="left">The implementation has been changed to use Boost.Chrono. 
        This has resulted in much improved resolution (1 microsecond on my 
        development machine) for wall clock time.</li>
        <li>
        <p align="left">There are now four classes:</li>
      </ul>
      <blockquote>
        <blockquote>
          <div align="left">
            <pre>class high_resolution_timer;       // wall clock time only
class auto_high_resolution_timer;  // automatic reporting
class cpu_timer;                   // wall, user, system time
class auto_cpu_timer;              // automatic reporting</pre>
          </div>
        </blockquote>
      </blockquote>
      <ul>
        <li>
        <p align="left">Formatting is now based on free function <code>format()</code> 
        with two overloads.</li>
      </ul>
      </td>
    </tr>
  </table>
  </center>
</div>

<h1>
<a name="Introduction">Introduction</a></h1>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
  <tr>
    <td width="100%" bgcolor="#D7EEFF" align="center">
      <i><b>Contents</b></i></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#E8F5FF">
      <p dir="ltr"><a href="#Introduction">Introduction</a><br>
      <a href="#Example">Examples</a><br>
      <a href="#Synopsis">Synopsis</a><br>
      <a href="#nanosecond_t">Typedef <code>nanosecond_type</code></a><br>
      <a href="#times_t">Struct <code>cpu_times</code></a><br>
      <a href="#Non-member-functions">Non-member functions</a><br>
      <a href="#timer">Class <code>timer</code></a><br>
&nbsp;&nbsp;&nbsp; <a href="#timer_members">Members</a><br>
      <a href="#run_timer">Class <code>run_timer</code></a><br>
&nbsp;&nbsp;&nbsp; <a href="#run_timer_members">Members</a><br>
      <a href="#Acknowledgements">Acknowledgements</a></td>
  </tr>
</table>

<p>Knowing how long a program takes to execute is useful in both test and 
production environments. It is also helpful if such timing information is broken down 
into wall clock time, CPU time spent by the user, and CPU time spent by the 
operating system servicing user requests.</p>
<ul>
  <li>The POSIX API provides that information via the <code>times()</code> 
  function. <br>
&nbsp;</li>
  <li>The Windows API provides that information via the <code>
  GetSystemTimeAsFileTime()</code> and <code>GetProcessTimes()</code> API's.<br>
&nbsp;</li>
  <li>Higher resolution / lower granularity timer functions will be used if 
  available.</li>
</ul>
<p>The Boost Timer Library timer components provide access to those, or 
similar, system API's with 
a portable and C++ friendly interface:</p>
<ul>
  <li>At the highest level, <a href="#run_timer">class <code><b>run_timer</b></code></a> provides a 
  complete run time reporting package that can be invoked in a single line of 
  code.<br>
&nbsp;</li>
  <li>At a middle level, <a href="#timer">class <code><b>timer</b></code></a> provides a widely useful timer 
  object abstraction.<br>
&nbsp;</li>
  <li>At the lowest level, two <a href="#Non-member-functions"><b> <code>times</code></b> functions</a> provide  
  thin wrappers around the operating system's actual API's.</li>
</ul>

<h2><a name="Example">Example</a>s</h2>

<p>Here is the <a href="../example/run_timer_example.cpp">run_timer_example.cpp</a> 
program supplied with the Boost Timer library:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main()
{
  boost::timer::run_timer t;

  for (long i = 0; i &lt; 10000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p dir="ltr">When the <code>run_timer t</code> object is created, it starts timing. When 
it is destroyed at the end of the program, its destructor stops the timer and 
displays timing information on an output stream that defaults to <code>std::cout</code>.</p>
<p>The output of this program run on a circa 2006 processor looks was this:</p>
<p><code>&nbsp;&nbsp; wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, 
(96.3%)</code></p>
<p>In other words, this program ran in 0.42 seconds as would be measured by a 
clock on the wall, the operating system charged it for 0.41 seconds of user CPU 
time and 0 seconds of system CPU time, the total of these two was 0.41, and that 
represented 96.3 percent of the wall clock time.</p>

<p>The <a href="../example/run_timer_example2.cpp">run_timer_example2.cpp</a> 
program is the same, except that it supplies additional constructor arguments 
from the command line:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main(int argc, char * argv[])
{
  const char* format = argc &gt; 1 ? argv[1] : &quot;%t cpu seconds\n&quot;;
  int places = argc &gt; 2 ? std::atoi( argv[2] ) : 2;

  boost::timer::run_timer t(format, places);

  for (long i = 0; i &lt; 10000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p>Here is the output for this program for several sets of command line 
arguments:</p>
<blockquote>
  <pre>run_timer_example2
0.42 cpu seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot;
0.41 wall clock seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot; 6
0.421875 wall clock seconds

run_timer_example2 &quot;%t total CPU seconds\n&quot; 3
0.422 total CPU seconds</pre>
</blockquote>
<h2><code>&lt;boost/timer/timer.hpp&gt;</code> <a name="Reference">Reference</a></h2>
<h3>
<font size="5"><a name="Synopsis">Synopsis</a></font></h3>
<div align="left">
<pre>namespace boost
{
  namespace timer
  {
    class <a href="#Class-high_resolution_timer">high_resolution_timer</a>;       // wall clock (AKA real) time  
    class <a href="#Class-auto_high_resolution_timer">auto_high_resolution_timer</a>;  // automatic reporting on destruction
    class <a href="#Class-cpu_timer">cpu_timer</a>;                   // wall, user, system time
    class <a href="#Class-auto_cpu_timer">auto_cpu_timer</a>;              // automatic reporting on destruction 

    typedef boost::int_least64_t nanosecond_type;

    struct cpu_times
    {
      nanosecond_type wall;
      nanosecond_type user;
      nanosecond_type system;

      void clear() { wall = user = system = 0LL; }
    };
      
    static const std::string   default_format;
    static const int           default_places = 6;

    std::string <a href="#format-time">format</a>(nanosecond_type time,
                       const std::string& fmt = default_format,
                       int places = default_places);

    std::string <a href="#format-times">format</a>(const cpu_times& times,
                       const std::string& format = default_format,
                       int places = default_places); 
  } // namespace timer
} // namespace boost
</pre>

</div>

<h3>Typedef <a name="nanosecond_type"><code>nanosecond_type</code></a></h3>

<p>The typedef <code>nanosecond_type</code> provides an implementation defined type capable 
of representing nanoseconds. For POSIX and Windows systems, <code>
nanoseconds_t</code> is <code>boost::int_least64_</code>t.</p>

<p>The underlying type is not based on the Boost Date-Time or Chrono library to avoid a 
dependency on a large library. This design choice may change at some future 
date.</p>

<p>Although <code>nanosecond_type</code> is capable of representing one <b>
nanosecond</b>, the actual resolution of common operating system timers may be 
much lower. For wall clock time on desktop systems circa 2011, resolution is 
often a bit less than one <b>microsecond</b>. For user and system time, typical 
resolutions is 15 <b>milliseconds</b> on Windows and 10 <b>milliseconds</b> on 
POSIX.</p>

<h3>Struct <a name="times_t"><code>cpu_times</code></a></h3>

<p>Struct <code>cpu_times</code> packages three elapsed times:</p>

<ul>
  <li>Wall clock elapsed time, equivalent to the time that would be recorded by 
  a stopwatch.</li>
  <li>User central processing unit (CPU) time used by the process, as charged by 
  the operating system.</li>
  <li>System central processing unit (CPU) time used by the process, as charged 
  by the operating system.</li>
</ul>

<h3><a name="Non-member-functions">Non-member functions</a></h3>

<pre>std::string <a name="format-time">format</a>(nanosecond_type time,
                   const std::string&amp; format = default_format,
                   int places = default_places);</pre>
<blockquote>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of <code>'%w'</code> are replaced by <code>time</code> in seconds, 
shown to <code>places</code> decimal places.</p>

</blockquote>

<pre>std::string <a name="format-times">format</a>(const cpu_times& times,
                   const std::string&amp; format = default_format,
                   int places = default_places);</pre>
<blockquote>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of the sequences shown below are replaced by the indicated value. 
Times are reported in seconds, 
shown to <code>places</code> decimal places. Percentage is reported to one 
decimal place. [<i>Note:</i> percentage may exceed 100% due to differences in 
how operating systems measure various times. <i>--end note</i>]</p>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="39%">
    <tr>
      <td width="25%"><b><i>Sequence</i></b></td>
      <td width="75%"><b><i>Replacement value</i></b></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%w</code></td>
      <td width="75%"><code>times.wall</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%u</code></td>
      <td width="75%"><code>times.user</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%s</code></td>
      <td width="75%"><code>times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%t</code></td>
      <td width="75%"><code>times.user + times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%p</code></td>
      <td width="75%">The percentage of <code>times.wall</code> represented by by <code>
      times.user + times.system</code></td>
    </tr>
  </table>
  </blockquote>

<h3><a name="Class-high_resolution_timer">Class <code>high_resolution_timer</code></a></h3>

<p> <code>high_resolution_timer_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<h3><a name="high_resolution_timer-synopsis"><code>high_resolution_timer</code> 
synopsis</a></h3>

<pre dir="ltr">    class <a name="high_resolution_timer">high_resolution_timer</a>
    {
    public:

      //  constructors
      high_resolution_timer() noexcept;

      //  observers
      bool             is_stopped() const noexcept;
      nanosecond_type  elapsed() const noexcept;
      std::string      format(const std::string& format = default_format,
                              int places = default_places) const;
      //  actions
      void             start() noexcept;
      nanosecond_type  stop() noexcept;
      void             resume() noexcept;

    private:
      nanosecond_type  m_time;         // <b><i>exposition only</i></b>
      bool             m_is_stopped;   // <b><i>exposition only</i></b>
    };</pre>
<h3><a name="high_resolution_timer-constructors"><code>high_resolution_timer</code> 
constructors</a></h3>
<pre>high_resolution_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> <code>start()</code>.</p>
</blockquote>
<h3><a name="high_resolution_timer-observers"><code>high_resolution_timer</code> 
observers</a></h3>
<pre>bool is_stopped() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> <code>m_is_stopped</code>.</p>
</blockquote>
<pre>nanosecond_type elapsed() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> If <code>is_stopped()</code>, <code>m_time</code>. 
  Otherwise, the difference between <code>m_time</code> and current wall-clock 
  time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>std::string format(const std::string&amp; format = default_format,
                   int places = default_places) const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>format(elapsed(), format, places)</code>.</p>
</blockquote>
<h3><a name="high_resolution_timer-actions"><code>high_resolution_timer</code> 
actions</a></h3>
<pre>void start() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>!is_stopped()</code> and <code>m_time</code> is 
set to the current wall-clock time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>nanosecond_type stop() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>is_stopped()</code> and <code>m_time</code> is 
set to the difference between <code>m_time</code> and current wall-clock time.</p>

<p><i>Returns:</i> <code>m_time,</code> after the establishment of the <i>
Postconditions</i>.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>void resume() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (is_stopped())
{
  nanosecond_type current (m_time);
  start();
  m_time -= current;
}</pre>
  </blockquote>
</blockquote>
<h3><a name="Class-auto_high_resolution_timer">Class <code>
auto_high_resolution_timer</code></a></h3>

<p>Class <code>auto_high_resolution_timer</code> adds a <code>report()</code> 
function to <code>class high_resolution_timer</code>, and automatically calls
<code>report()</code> on destruction.</p>

<h3 dir="ltr"> <code>auto_high_resolution_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="auto_high_resolution_timer">auto_high_resolution_timer</a> : public high_resolution_timer
    {
    public:

      //  constructors
      explicit auto_high_resolution_timer(int places = default_places) noexcept;

      auto_high_resolution_timer(int places, std::ostream& os) noexcept;

      explicit auto_high_resolution_timer(const std::string& format,
                                          int places = default_places);
      
      auto_high_resolution_timer(const std::string& format,
                                 int places, std::ostream& os);

      //  destructor
     ~auto_high_resolution_timer() noexcept; 

      //  actions
      void report();

    private:
      int             m_places;       // <b><i>exposition only</i></b>
      std::ostream&   m_os;           // <b><i>exposition only</i></b>
      std::string     m_format;       // <b><i>exposition only</i></b>
    };</pre>
<p dir="ltr">Constructors without a <code>std::ostream&</code> argument assume
<code>std::cout</code>. An explicit default argument is not provided because it would require 
a high-cost include of <code>&lt;iostream&gt;</code>, even when the standard streams are not used.</p>
<h3 dir="ltr"><code>auto_high_resolution_timer</code> constructors</h3>
<pre dir="ltr">explicit auto_high_resolution_timer(int places = default_places) noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Effects:</i> Constructs an object of type <code>
  auto_high_resolution_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == std::cout,<br>
&nbsp; m_format == default_format</code></p>
</blockquote>
<pre dir="ltr">auto_high_resolution_timer(int places, std::ostream& os) noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Effects:</i> Constructs an object of type <code>
  auto_high_resolution_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == os,<br>
&nbsp; m_format == default_format</code></p>
</blockquote>
<pre dir="ltr">explicit auto_high_resolution_timer(const std::string& format,
                                    int places = default_places);</pre>
<blockquote>
  <p dir="ltr"><i>Effects:</i> Constructs an object of type <code>
  auto_high_resolution_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == std::cout,<br>
&nbsp; m_format == format</code></p>
</blockquote>
<pre dir="ltr">auto_high_resolution_timer(const std::string& format,
                           int places, std::ostream& os);</pre>
<blockquote>
  <p dir="ltr"><i>Effects:</i> Constructs an object of type <code>
  auto_high_resolution_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == os,<br>
&nbsp; m_format == format</code></p>
</blockquote>
<h3 dir="ltr"><code>auto_high_resolution_timer</code> destructor</h3>
<pre dir="ltr">~auto_high_resolution_timer() noexcept;</pre>
<blockquote>
<p dir="ltr"><i>Effects: </i>As if:</p>
  <blockquote>
    <pre dir="ltr">if (!is_stopped())
{
  try
  {
    report();
  }
  catch (...)
  {
  }
}</pre>
  </blockquote>
</blockquote>
<h3 dir="ltr"><code>auto_high_resolution_timer</code> actions</h3>
<pre dir="ltr">void report();</pre>
<blockquote>
  <p dir="ltr"><i>Effects: </i>As if:</p>
  <blockquote>
    <pre dir="ltr">m_os &lt;&lt; timer::report(stop(),
                      m_format.empty()
                        ? &quot; %ws elapsed wall clock time\n&quot;
                        : m_format,
                      m_places</pre>
  </blockquote>
</blockquote>
<h3><a name="Class-cpu_timer">Class <code>cpu_timer</code></a></h3>

<p> <code>cpu_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<p dir="ltr">Wall-clock elapsed time is measured by the Boost.Chrono <code>
high_resolution_clock</code>. User and system times are measured by operating 
system API functions such as <code>times()</code> on POSIX and <code>
GetProcessTimes()</code> on Windows.</p>

<h3 dir="ltr"> <code>cpu_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="cpu_timer">cpu_timer</a>
    {
    public:

      //  constructors
      cpu_timer() noexcept;

      //  observers
      bool              is_stopped() const noexcept;
      cpu_times         elapsed() const noexcept;
      std::string       format(const std::string& format = default_format,
                               int places = default_places) const;
      //  actions
      void              start() noexcept;
      const cpu_times&  stop() noexcept;
      void              resume() noexcept;

    private:
      cpu_times         m_times;          // <b><i>exposition only</i></b>
      bool              m_is_stopped;     // <b><i>exposition only</i></b>
    };</pre>
<h3><a name="cpu_timer-constructors"><code>cpu_timer</code> 
constructors</a></h3>
<pre>cpu_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> <code>start()</code>.</p>
</blockquote>
<h3><a name="cpu_timer-observers"><code>cpu_timer</code> 
observers</a></h3>
<pre>bool is_stopped() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> <code>m_is_stopped</code>.</p>
</blockquote>
<pre>nanosecond_type elapsed() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> If <code>is_stopped()</code>, <code>m_time</code>. 
  Otherwise, the difference between <code>m_time</code> and current wall-clock 
  time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
cpu_clock</code>.</p>

</blockquote>
<pre>std::string format(const std::string&amp; format = default_format,
                   int places = default_places) const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>format(elapsed(), format, places)</code>.</p>
</blockquote>
<h3><a name="cpu_timer-actions"><code>cpu_timer</code> 
actions</a></h3>
<pre>void start() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>!is_stopped()</code> and <code>m_time</code> is 
set to the current wall-clock time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
cpu_clock</code>.</p>

</blockquote>
<pre>nanosecond_type stop() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>is_stopped()</code> and <code>m_time</code> is 
set to the difference between <code>m_time</code> and current wall-clock time.</p>

<p><i>Returns:</i> <code>m_time,</code> after the establishment of the <i>
Postconditions</i>.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
cpu_clock</code>.</p>

</blockquote>
<pre>void resume() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (is_stopped())
{
  nanosecond_type current (m_time);
  start();
  m_time -= current;
}</pre>
  </blockquote>
</blockquote>
<h3 dir="ltr"><a name="Class-auto_cpu_timer">Class <code>auto_cpu_timer</code></a></h3>

<p dir="ltr">Class <code>auto_cpu_timer</code> adds a <code>report()</code> 
function to <code>class cpu_timer</code>, and automatically calls <code>report()</code> 
on destruction.</p>

<h3 dir="ltr"> <code>auto_cpu_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="auto_cpu_timer">auto_cpu_timer</a> : public cpu_timer
    {
    public:
      explicit
      auto_cpu_timer(int places = default_places) noexcept;

      auto_cpu_timer(int places, std::ostream& os) noexcept;

      explicit
      auto_cpu_timer(const std::string& format,
                     int places = default_places);

      auto_cpu_timer(const std::string& format,
                     int places, std::ostream& os);

     ~auto_cpu_timer() noexcept;

      void            report();

    private:
      int             m_places;           // <b><i>exposition only</i></b>
      std::ostream&   m_os;               // <b><i>exposition only</i></b>
      std::string     m_format;           // <b><i>exposition only</i></b>
    };</pre>
<p>Each constructor has two overloads to avoid an explicit default to <code>
std::cout</code>. Such a default would require including <code>&lt;iostream&gt;</code>, 
with its high costs, even when the standard streams are not used.</p>

  <h2><a name="FAQ">FAQ</a></h2>

  <p>&nbsp;</p>

  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Rob Stewart contributed many corrections, comments, and suggestions. In 
  particular, he suggested the <code>resume()</code> and <code>format()</code> 
  functions, resulting in improved ease-of-use for several use cases.</p>

<hr>
<p><font size="2">Last revised:
<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->24 September, 2011<!--webbot bot="Timestamp" endspan i-checksum="39338" --></font></p>
<p><font size="2">© Copyright Beman Dawes, 2006, 2011</font></p>
<p><font size="2">Distributed under the Boost Software License, Version 1.0.  See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></font></p>

</body>

</html>