<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Boost System Timers</title>
  <link rel="stylesheet" type="text/css" href=
  "../../../doc/src/minimal.css">
</head>

<body>

<h1><img border="0" src="../../../boost.png" align="center" width="277" height="86"> 
Boost Timer Library Version 2<br>
&nbsp;</h1>
<div align="center">
  <center>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="70%" bgcolor="#CCFFFF">
    <tr>
      <td width="100%">
      <p align="center"><font size="6"><b>This is a major revision of the 
      Version 2 draft</b></font><b><font size="6">!</font></b></p>
      <ul>
        <li>
        <p align="left">The original content of the Boost.Timer library is now 
        deprecated.</li>
        <li>
        <p align="left">The new headers for Boost.Timer are in <code>
        &lt;boost/timer/...&gt;</code></li>
        <li>
        <p align="left">All new content is in namespace <code>boost::timer</code>. </li>
        <li>
        <p align="left">The unit of time has been changed from microseconds to 
        nanoseconds.</li>
        <li>
        <p align="left">The implementation has been changed to use Boost.Chrono. 
        This has resulted in much improved resolution (1 microsecond on my 
        development machine) for wall clock time.</li>
        <li>
        <p align="left">There are now four classes:</li>
      </ul>
      <blockquote>
        <blockquote>
          <div align="left">
            <pre>class high_resolution_timer;       // wall clock time only
class auto_high_resolution_timer;  // automatic reporting
class cpu_timer;                   // wall, user, system time
class auto_cpu_timer;              // automatic reporting</pre>
          </div>
        </blockquote>
      </blockquote>
      <ul>
        <li>
        <p align="left">Formatting is now based on free function <code>format()</code> 
        with two overloads.</li>
      </ul>
      </td>
    </tr>
  </table>
  </center>
</div>

<h1>
<a name="Introduction">Introduction</a></h1>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
  <tr>
    <td width="100%" bgcolor="#D7EEFF" align="center">
      <i><b>Contents</b></i></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#E8F5FF">
      <p dir="ltr"><a href="#Introduction">Introduction</a><br>
      <a href="#Example">Examples</a><br>
      <a href="#Synopsis">Synopsis</a><br>
      <a href="#nanosecond_t">Typedef <code>nanosecond_type</code></a><br>
      <a href="#times_t">Struct <code>cpu_times</code></a><br>
      <a href="#Non-member-functions">Non-member functions</a><br>
      <a href="#timer">Class <code>timer</code></a><br>
&nbsp;&nbsp;&nbsp; <a href="#timer_members">Members</a><br>
      <a href="#run_timer">Class <code>run_timer</code></a><br>
&nbsp;&nbsp;&nbsp; <a href="#run_timer_members">Members</a><br>
      <a href="#Acknowledgements">Acknowledgements</a></td>
  </tr>
</table>

<p>Knowing how long a program takes to execute is useful in both test and 
production environments. It is also helpful if such timing information is broken down 
into wall clock time, CPU time spent by the user, and CPU time spent by the 
operating system servicing user requests.</p>
<ul>
  <li>The POSIX API provides that information via the <code>times()</code> 
  function. <br>
&nbsp;</li>
  <li>The Windows API provides that information via the <code>
  GetSystemTimeAsFileTime()</code> and <code>GetProcessTimes()</code> API's.<br>
&nbsp;</li>
  <li>Higher resolution / lower granularity timer functions will be used if 
  available.</li>
</ul>
<p>The Boost Timer Library timer components provide access to those, or 
similar, system API's with 
a portable and C++ friendly interface:</p>
<ul>
  <li>At the highest level, <a href="#run_timer">class <code><b>run_timer</b></code></a> provides a 
  complete run time reporting package that can be invoked in a single line of 
  code.<br>
&nbsp;</li>
  <li>At a middle level, <a href="#timer">class <code><b>timer</b></code></a> provides a widely useful timer 
  object abstraction.<br>
&nbsp;</li>
  <li>At the lowest level, two <a href="#Non-member-functions"><b> <code>times</code></b> functions</a> provide  
  thin wrappers around the operating system's actual API's.</li>
</ul>

<h2><a name="Example">Example</a>s</h2>

<p>Here is the <a href="../example/run_timer_example.cpp">run_timer_example.cpp</a> 
program supplied with the Boost Timer library:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main()
{
  boost::timer::run_timer t;

  for (long i = 0; i &lt; 10000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p dir="ltr">When the <code>run_timer t</code> object is created, it starts timing. When 
it is destroyed at the end of the program, its destructor stops the timer and 
displays timing information on an output stream that defaults to <code>std::cout</code>.</p>
<p>The output of this program run on a circa 2006 processor looks was this:</p>
<p><code>&nbsp;&nbsp; wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, 
(96.3%)</code></p>
<p>In other words, this program ran in 0.42 seconds as would be measured by a 
clock on the wall, the operating system charged it for 0.41 seconds of user CPU 
time and 0 seconds of system CPU time, the total of these two was 0.41, and that 
represented 96.3 percent of the wall clock time.</p>

<p>The <a href="../example/run_timer_example2.cpp">run_timer_example2.cpp</a> 
program is the same, except that it supplies additional constructor arguments 
from the command line:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main(int argc, char * argv[])
{
  const char* format = argc &gt; 1 ? argv[1] : &quot;%t cpu seconds\n&quot;;
  int places = argc &gt; 2 ? std::atoi( argv[2] ) : 2;

  boost::timer::run_timer t(format, places);

  for (long i = 0; i &lt; 10000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p>Here is the output for this program for several sets of command line 
arguments:</p>
<blockquote>
  <pre>run_timer_example2
0.42 cpu seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot;
0.41 wall clock seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot; 6
0.421875 wall clock seconds

run_timer_example2 &quot;%t total CPU seconds\n&quot; 3
0.422 total CPU seconds</pre>
</blockquote>
<h2><code>&lt;boost/timer/timer.hpp&gt;</code> <a name="Reference">Reference</a></h2>
<h3>
<font size="5"><a name="Synopsis">Synopsis</a></font></h3>
<div align="left">
<pre>namespace boost
{
  namespace timer
  {
    class <a href="#Class-high_resolution_timer">high_resolution_timer</a>;       // wall clock (AKA real) time  
    class <a href="#Class-auto_high_resolution_timer">auto_high_resolution_timer</a>;  // automatic reporting on destruction
    class <a href="#Class-cpu_timer">cpu_timer</a>;                   // wall, user, system time
    class <a href="#Class-auto_cpu_timer">auto_cpu_timer</a>;              // automatic reporting on destruction 

    typedef boost::int_least64_t nanosecond_type;

    struct cpu_times
    {
      nanosecond_type wall;
      nanosecond_type user;
      nanosecond_type system;

      void clear() { wall = user = system = 0LL; }
    };
      
    static const std::string   default_format;
    static const int           default_places = 6;

    std::string <a href="#format-time">format</a>(nanosecond_type time,
                       const std::string& fmt = default_format,
                       int places = default_places);

    std::string <a href="#format-times">format</a>(const cpu_times& times,
                       const std::string& format = default_format,
                       int places = default_places); 
  } // namespace timer
} // namespace boost
</pre>

</div>

<h3>Typedef <a name="nanosecond_type"><code>nanosecond_type</code></a></h3>

<p>The typedef <code>nanosecond_type</code> provides an implementation defined type capable 
of representing nanoseconds. For POSIX and Windows systems, <code>
nanoseconds_t</code> is <code>boost::int_least64_</code>t.</p>

<p>The underlying type is not based on the Boost Date-Time or Chrono library to avoid a 
dependency on a large library. This design choice may change at some future 
date.</p>

<p>Although <code>nanosecond_type</code> is capable of representing one <b>
nanosecond</b>, the actual resolution of common operating system timers may be 
much lower. For wall clock time on desktop systems circa 2011, resolution is 
often a bit less than one <b>microsecond</b>. For user and system time, typical 
resolutions is 15 <b>milliseconds</b> on Windows and 10 <b>milliseconds</b> on 
POSIX.</p>

<h3>Struct <a name="times_t"><code>cpu_times</code></a></h3>

<p>Struct <code>cpu_times</code> packages three elapsed times:</p>

<ul>
  <li>Wall clock elapsed time, equivalent to the time that would be recorded by 
  a stopwatch.</li>
  <li>User central processing unit (CPU) time used by the process, as charged by 
  the operating system.</li>
  <li>System central processing unit (CPU) time used by the process, as charged 
  by the operating system.</li>
</ul>

<h3><a name="Non-member-functions">Non-member functions</a></h3>

<pre>std::string <a name="format-time">format</a>(nanosecond_type time,
                   const std::string&amp; format = default_format,
                   int places = default_places);</pre>
<blockquote>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of <code>'%w'</code> are replaced by <code>time</code> in seconds, 
shown to <code>places</code> decimal places.</p>

</blockquote>

<pre>std::string <a name="format-times">format</a>(const cpu_times& times,
                   const std::string&amp; format = default_format,
                   int places = default_places);</pre>
<blockquote>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of the sequences shown below are replaced by the indicated value. 
Times are reported in seconds, 
shown to <code>places</code> decimal places. Percentage is reported to one 
decimal place. [<i>Note:</i> percentage may exceed 100% due to differences in 
how operating systems measure various times. <i>--end note</i>]</p>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="39%">
    <tr>
      <td width="25%"><b><i>Sequence</i></b></td>
      <td width="75%"><b><i>Replacement value</i></b></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%w</code></td>
      <td width="75%"><code>times.wall</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%u</code></td>
      <td width="75%"><code>times.user</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%s</code></td>
      <td width="75%"><code>times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%t</code></td>
      <td width="75%"><code>times.user + times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%p</code></td>
      <td width="75%">The percentage of <code>times.wall</code> represented by by <code>
      times.user + times.system</code></td>
    </tr>
  </table>
  </blockquote>

<h3><a name="Class-high_resolution_timer">Class <code>high_resolution_timer</code></a></h3>

<p> <code>high_resolution_timer_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<p dir="ltr">Wall-clock elapsed time is measured by the Boost.Chrono <code>
high_resolution_clock</code>.</p>

<h3 dir="ltr">high_resolution_timer synopsis</h3>

<pre dir="ltr">    class <a name="high_resolution_timer">high_resolution_timer</a>
    {
    public:

      //  constructors, destructor
      high_resolution_timer();
     ~high_resolution_timer();

      //  observers
      bool             is_stopped() const;
      nanosecond_type  elapsed() const;
      std::string      format(const std::string& fmt = default_format,
                              int places = default_places) const;
      //  actions
      void             start();
      nanosecond_type  stop();
      void             resume();

    private:
      nanosecond_type  m_time;         // <b><i>exposition only</i></b>
      bool             m_is_stopped;   // <b><i>exposition only</i></b>
    };
 </pre>
<h3><a name="Class-auto_high_resolution_timer">Class <code>
auto_high_resolution_timer</code></a></h3>

<p>Class <code>auto_high_resolution_timer</code> adds a <code>report()</code> 
function to <code>class high_resolution_timer</code>, and automatically calls
<code>report()</code> on destruction.</p>

<h3 dir="ltr"> <code>auto_high_resolution_timer</code> synopsis</h3>

<pre dir="ltr">
    class <a name="auto_high_resolution_timer">auto_high_resolution_timer</a> : public high_resolution_timer
    {
    public:

      explicit
      auto_high_resolution_timer(int places = default_places);

      auto_high_resolution_timer(int places, std::ostream& os);

      explicit
      auto_high_resolution_timer(const std::string& format,
                                 int places = default_places);
      
      auto_high_resolution_timer(const std::string& format,
                                 int places, std::ostream& os);
 
     ~auto_high_resolution_timer();  // if !is_stopped(), report()

      void report();

    private:
      int             m_places;       // <b><i>exposition only</i></b>
      std::ostream&   m_os;           // <b><i>exposition only</i></b>
      std::string     m_format;       // <b><i>exposition only</i></b>
    };</pre>
<p dir="ltr">Each constructor has two overloads to avoid an explicit default to
<code>std::cout</code>. Such a default would require including <code>&lt;iostream&gt;</code>, 
with its high costs, even when the standard streams are not used.</p>
<h3><a name="Class-cpu_timer">Class <code>cpu_timer</code></a></h3>

<p> <code>cpu_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<p dir="ltr">Wall-clock elapsed time is measured by the Boost.Chrono <code>
high_resolution_clock</code>. User and system times are measured by operating 
system API functions such as <code>times()</code> on POSIX and <code>
GetProcessTimes()</code> on Windows.</p>

<h3 dir="ltr"> <code>cpu_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="cpu_timer">cpu_timer</a>
    {
    public:

      //  constructors, destructor
      cpu_timer();
     ~cpu_timer();

      //  observers
      bool              is_stopped() const;
      cpu_times         elapsed() const;
      std::string       format(const std::string& fmt = default_format,
                               int places = default_places) const;
      //  actions
      void              start();
      const cpu_times&  stop();
      void              resume();

    private:
      cpu_times         m_times;          // <b><i>exposition only</i></b>
      bool              m_is_stopped;     // <b><i>exposition only</i></b>
    };</pre>
<h3 dir="ltr"><a name="Class-auto_cpu_timer">Class <code>auto_cpu_timer</code></a></h3>

<p dir="ltr">Class <code>auto_cpu_timer</code> adds a <code>report()</code> 
function to <code>class cpu_timer</code>, and automatically calls <code>report()</code> 
on destruction.</p>

<h3 dir="ltr"> <code>auto_cpu_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="auto_cpu_timer">auto_cpu_timer</a> : public cpu_timer
    {
    public:
      explicit
      auto_cpu_timer(int places = default_places);

      auto_cpu_timer(int places, std::ostream& os);

      explicit
      auto_cpu_timer(const std::string& format,
                     int places = default_places);

      auto_cpu_timer(const std::string& format,
                     int places, std::ostream& os);

     ~auto_cpu_timer();  // if !is_stopped(), report()

      void            report();

    private:
      int             m_places;           // <b><i>exposition only</i></b>
      std::ostream&   m_os;               // <b><i>exposition only</i></b>
      std::string     m_format;           // <b><i>exposition only</i></b>
    };</pre>
<p>Each constructor has two overloads to avoid an explicit default to <code>
std::cout</code>. Such a default would require including <code>&lt;iostream&gt;</code>, 
with its high costs, even when the standard streams are not used.</p>
<h3>Class <a name="timer_members"><code>timer</code> members</a></h3>

<p><code>timer();</code></p>

<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>

</blockquote>

<p><code>timer(const std::nothrow_t&amp;);</code></p>

<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>

<p><i>Remarks:</i> Member functions for this object will not throw exceptions.</p>

<p><i>Note: </i>On popular operating systems, such as POSIX and Windows,  the question of how to handle errors is moot 
since timer errors do no occur. For programs which may 
run on systems that may possibly report timer errors, the <code>nothrow</code> 
constructor allows suppression of exceptions without the interface thickening 
that would be required if all functions had <code>error_code</code> returning 
variations. In the rare cases where exceptions are undesirable yet the <code>
error_code</code> must be captured,&nbsp; the non-member <code>times</code> 
function's overload returning an <code>error_code</code> can be used.</p>

</blockquote>
<p><code>~timer();</code></p>

<blockquote>
<p><i>Effects:</i> None.</p>

<p><i>Throws:</i> Never.</p>

</blockquote>
<p><code>void start();</code></p>

<blockquote>
<p><i>Effects:</i> Begins measuring 
wall-clock, user process, and system process elapsed time.</p>

<p><i>Postconditions:</i> <code>stopped() == false</code>.</p>

</blockquote>
<p><code>const cpu_times&amp; stop();</code></p>

<blockquote>
<p><i>Effects:</i> If <code>!stopped()</code>, stops measuring wall-clock, user 
CPU, and system CPU elapsed time, and stores in a <code>time_t</code> struct the time 
elapsed since the 
preceding invocation of <code>start()</code>. Otherwise, has no effect.</p>

<p><i>Returns:</i> A reference to the <code>time_t</code> struct.</p>

<p><i>Postconditions:</i> <code>stopped() == true</code>.</p>

</blockquote>

<p><code>bool stopped() const;</code></p>

<blockquote>

<p><i>Returns:</i> true if <code>stop()</code> has been called subsequent to a call to
<code>start()</code>, else <code>false</code>.</p>

</blockquote>

<p><code>void elapsed(cpu_times&amp; result);</code></p>

<blockquote>

<p><i>Effects:</i> Stores wall-clock, process user CPU, and process system CPU elapsed times 
in r<code>esult</code>. 
If <code>stopped() == false,</code> the times are those measured since the 
preceding invocation of <code>start()</code>, otherwise the times are those 
stored by the preceding invocation of <code>stop()</code>.</p>

<p><i>Remark:</i> Does not call <code>stop()</code>.</p>

</blockquote>

<h3>Class <a name="run_timer">run_timer</a></h3>

<p>Class <code>run_timer</code> inherits publicly from <code><a href="#timer">
timer</a></code>. For the description of inherited functions, see
<a href="#timer">Class <code>timer</code>.</a></p>

<h3>Class <a name="run_timer_members">run_timer members</a></h3>

<pre>explicit run_timer(int places = 2);</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>run_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == std::cout,<br>
&nbsp; m_format == &quot; %ws wall, %us user + %ss system = %ts cpu (%p%)\n&quot;</code></p>
</blockquote>
<pre>run_timer(int places, std::ostream&amp; os);</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>run_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_places == places,<br>
&nbsp; m_os == os,<br>
&nbsp; m_format == &quot; %ws wall, %us user + %ss system = %ts cpu (%p%)\n&quot;</code></p>
</blockquote>
<pre>explicit run_timer(const std::string&amp; format, int places = 2);</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>run_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_format == format,<br>
&nbsp; m_places == places,<br>
&nbsp; m_os == std::cout&nbsp; </code></p>
</blockquote>
<pre>run_timer(const std::string&amp; format, int places, std::ostream &amp; os);</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of type <code>run_timer</code>.</p>
  <p><i>Postconditions:<br>
  </i><code>&nbsp; m_format == format,<br>
&nbsp; m_places == places,<br>
&nbsp; m_os == os&nbsp; </code></p>
</blockquote>
<pre>~run_timer();</pre>
<blockquote>
  <p><i>Effects:</i> <br>
  <code>&nbsp; error_code ed;<br>
&nbsp; if (!stopped()) report(ec);</code></p>
<p><i>Throws:</i> Never.</p>

</blockquote>
<pre>void report();</pre>
<blockquote>
  <p><i>Effects:</i> Same as <code>report(error_code &amp; ec)</code>. See below.</p>
  <p><i>Note: </i>Does throw on errors.</p>
</blockquote>
<pre>error_code report(error_code &amp; ec);</pre>
<blockquote>

<p><i>Effects: </i>Displays times on <code>m_os</code>:</p>

  <ul>
    <li><code>stop()</code>.</li>
    <li>Saves <code>m_os</code> <code>ios</code> flags and precision.</li>
    <li>Sets <code>m_os</code>&nbsp; <code>ios</code> flags and precision as if by:<ul>
      <li><code>m_os.setf(std::ios_base::fixed, std::ios_base::floatfield)</code></li>
      <li><code>m_os.precision(m_places)</code></li>
    </ul>
    </li>
    <li>Outputs <code>m_format</code> to <code>m_os</code>, replacing the character 
    sequences shown in the table below with the indicated values.</li>
    <li>Restores saved <code>iso</code> flags and precision.</li>
    <li>If an error occurs during output, sets <code>ec</code> to the 
    corresponding error condition. Otherwise, calls <code>ec.clear()</code>.</li>
</ul>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="39%">
    <tr>
      <td width="25%"><b><i>Sequence</i></b></td>
      <td width="75%"><b><i>Replacement value</i></b></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%w</code></td>
      <td width="75%"><code>wall()</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%u</code></td>
      <td width="75%"><code>user()</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%s</code></td>
      <td width="75%"><code>system()</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%t</code></td>
      <td width="75%"><code>user()+system()</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%p</code></td>
      <td width="75%">The percentage of <code>wall()</code> represented by by <code>
      user()+system()</code></td>
    </tr>
  </table>
  <p><i>Returns:</i> <code>ec</code></p>
  <p><i>Throws:</i> Never.</p>
</blockquote>

  <h2><a name="FAQ">FAQ</a></h2>

  <p>&nbsp;</p>

  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Rob Stewart contributed many corrections, comments, and suggestions. In 
  particular, he suggested the <code>resume()</code> and <code>format()</code> 
  functions, resulting in improved ease-of-use for several use cases.</p>

<hr>
<p><font size="2">Last revised:
<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->24 September, 2011<!--webbot bot="Timestamp" endspan i-checksum="39338" --></font></p>
<p><font size="2">© Copyright Beman Dawes, 2006, 2011</font></p>
<p><font size="2">Distributed under the Boost Software License, Version 1.0.  See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></font></p>

</body>

</html>