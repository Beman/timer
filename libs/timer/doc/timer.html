<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Boost System Timers</title>
  <link rel="stylesheet" type="text/css" href=
  "../../../doc/src/minimal.css">
</head>

<body>

<h1><img border="0" src="../../../boost.png" align="center" width="277" height="86"> 
Boost Timer Library Version 2<br>
&nbsp;</h1>
<div align="center">
  <center>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="70%" bgcolor="#CCFFFF">
    <tr>
      <td width="100%">
      <p align="center"><font size="6"><b>This is a major revision of the 
      Version 2 draft</b></font><b><font size="6">!</font></b></p>
      <ul>
        <li>
        <p align="left">The original content of the Boost.Timer library is now 
        deprecated.</li>
        <li>
        <p align="left">The new headers for Boost.Timer are in <code>
        &lt;boost/timer/...&gt;</code></li>
        <li>
        <p align="left">All new content is in namespace <code>boost::timer</code>. </li>
        <li>
        <p align="left">The unit of time has been changed from microseconds to 
        nanoseconds.</li>
        <li>
        <p align="left">The wall-clock time implementation has been changed to use Boost.Chrono. 
        This has resulted in much improved resolution (1 microsecond on my 
        development machine) for wall clock time.</li>
        <li>
        <p align="left">There are now two classes:</li>
      </ul>
      <blockquote>
        <blockquote>
          <div align="left">
            <pre>class high_resolution_timer;       // wall-clock time
class cpu_timer;                   // wall, user, system time</pre>
          </div>
        </blockquote>
      </blockquote>
      <ul>
        <li>
        <p align="left">Formatting is now based on free function <code>format()</code>.</li>
      </ul>
      </td>
    </tr>
  </table>
  </center>
</div>

<h2><a name="Introduction">Introduction</a></h2>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" align="right">
  <tr>
    <td width="100%" bgcolor="#D7EEFF" align="center">
      <i><b>Contents</b></i></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="#E8F5FF">
      <a href="#Introduction">Introduction</a><br>
      <a href="#Example">Examples</a><br>
      <a href="#Non-member-functions">Non-member functions</a><br>
      <a href="#Class-high_resolution_timer">Class <code>high_resolution_timer</code></a><br>
      <code>&nbsp; <a href="#high_resolution_timer-synopsis">high_resolution_timer</a></code><a href="#high_resolution_timer-synopsis"> 
synopsis</a><br>
      <code>&nbsp; <a href="#high_resolution_timer-constructors">high_resolution_timer</a></code><a href="#high_resolution_timer-constructors"> 
constructors,</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#high_resolution_timer-constructors">destructor</a><br>
      &nbsp;&nbsp;<code> <a href="#high_resolution_timer-observers">high_resolution_timer</a></code><a href="#high_resolution_timer-observers"> 
observers</a><br>
      &nbsp;&nbsp; &nbsp;<a href="#high_resolution_timer-actions"><code>high_resolution_timer</code> 
actions</a><br>
      <a href="#Class-cpu_timer">Class <code>cpu_timer</code></a><br>
      &nbsp;&nbsp;<code> <a href="#cpu_timer-constructors">cpu_timer</a></code><a href="#cpu_timer-constructors"> 
constructors, destructor</a><br>
      &nbsp;&nbsp;<code> <a href="#cpu_timer-observers">cpu_timer</a></code><a href="#cpu_timer-observers"> 
observers</a><br>
      &nbsp;&nbsp;<code> <a href="#cpu_timer-actions">cpu_timer</a></code><a href="#cpu_timer-actions"> 
actions</a><br>
      <a href="#FAQ">FAQ</a><br>
      <a href="#Acknowledgements">Acknowledgements</a><br>
  </tr>
</table>

<p>Knowing how long a program takes to execute is useful in both test and 
production environments. It may also be helpful if such timing information is broken down 
into wall clock time, CPU time spent by the user, and CPU time spent by the 
operating system servicing user requests.</p>

<p>Boost.Timer provides two classes to provide these times:</p>

<blockquote>
            <pre>class <a href="#Class-high_resolution_timer">high_resolution_timer</a>;       // wall-clock time
class <a href="#Class-cpu_timer">cpu_timer</a>;                   // wall, user, system time</pre>
          </blockquote>

<p>Since high-resolution timers are sub-sets</p>

<h2><a name="Example">Examples</a></h2>

<p>Here is <a href="../example/cpu_timer_example.cpp">cpu_timer_example.cpp</a>, supplied with the Boost Timer library:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main()
{
  boost::timer::cpu_timer t(-1);

  for (long i = 0; i &lt; 100000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p dir="ltr">When the <code>cpu_timer t</code> object is created, it starts timing. When 
it is destroyed at the end of the program, its destructor stops the timer and 
displays timing information on an output stream that defaults to <code>std::cout</code>.</p>
<p>The output of this program, run with a debug build on a circa 2006 desktop processor:</p>
<p><code>&nbsp;&nbsp;&nbsp; 5.713010s wall, 5.709637s user + 0.000000s system = 
5.709637s cpu (99.9%)</code></p>
<p>In other words, this program ran in  <code>5.713010</code> seconds as would be measured by a 
clock on the wall, the operating system charged it for  <code>5.709637</code> seconds of user CPU 
time and 0 seconds of system CPU time, the total of these two was  <code>5.709637</code>, and that 
represented  <code>99.9</code> percent of the wall clock time.</p>

<p>The <a href="../example/cpu_timer_example2.cpp">cpu_timer_example2.cpp</a> 
program is the same, except that it supplies additional constructor arguments 
from the command line:</p>
<blockquote>
  <pre>#include &lt;boost/timer/timer.hpp&gt;
#include &lt;cmath&gt;

int main(int argc, char * argv[])
{
  const char* format = argc &gt; 1 ? argv[1] : &quot;%t cpu seconds\n&quot;;
  int places = argc &gt; 2 ? std::atoi( argv[2] ) : 2;

  boost::timer::cpu_timer t(format, places);

  for (long i = 0; i &lt; 10000000; ++i)
    std::sqrt(123.456L); // burn some time

  return 0;
}</pre>
</blockquote>
<p>Here is the output for this program for several sets of command line 
arguments:</p>
<blockquote>
  <pre>run_timer_example2
0.42 cpu seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot;
0.41 wall clock seconds

run_timer_example2 &quot;%w wall clock seconds\n&quot; 6
0.421875 wall clock seconds

run_timer_example2 &quot;%t total CPU seconds\n&quot; 3
0.422 total CPU seconds</pre>
</blockquote>
<h2><code>&lt;boost/timer/timer.hpp&gt;</code> <a name="Reference">Reference</a></h2>
<h3>
<font size="5"><a name="Synopsis">Synopsis</a></font></h3>
<div align="left">
<pre>namespace boost
{
  namespace timer
  {
    class <a href="#Class-high_resolution_timer">high_resolution_timer</a>;       // wall clock (AKA real) time  
    class <a href="#Class-cpu_timer">cpu_timer</a>;                   // wall, user, system time

    typedef boost::int_least64_t nanosecond_type;

    struct cpu_times
    {
      nanosecond_type wall;
      nanosecond_type user;
      nanosecond_type system;

      void clear() { wall = user = system = 0LL; }
    };
      
    static const std::string   default_format;
    static const int           default_places = 6;

    std::string format(nanosecond_type time,
                       short places = default_places,
                       const std::string&amp; format = default_format);

    std::string format(const cpu_times&amp; times,
                       short places = default_places,
                       const std::string&amp; format = default_format); 
  } // namespace timer
} // namespace boost
</pre>

</div>

<h3>Typedef <a name="nanosecond_type"><code>nanosecond_type</code></a></h3>

<p>The typedef <code>nanosecond_type</code> provides an implementation defined type capable 
of representing nanoseconds. For POSIX and Windows systems, <code>
nanoseconds_t</code> is <code>boost::int_least64_</code>t.</p>

<p>The underlying type is not based on the Boost Date-Time or Chrono library to avoid a 
dependency on a large library. This design choice may change at some future 
date.</p>

<p>Although <code>nanosecond_type</code> is capable of representing one <b>
nanosecond</b>, the actual resolution of common operating system timers may be 
much lower. For wall clock time on desktop systems circa 2011, resolution is 
often a bit less than one <b>microsecond</b>. For user and system time, typical 
resolutions is 15 <b>milliseconds</b> on Windows and 10 <b>milliseconds</b> on 
POSIX.</p>

<h3>Struct <a name="times_t"><code>cpu_times</code></a></h3>

<p>Struct <code>cpu_times</code> packages three elapsed times:</p>

<ul>
  <li>Wall clock elapsed time, equivalent to the time that would be recorded by 
  a stopwatch.</li>
  <li>User central processing unit (CPU) time used by the process, as charged by 
  the operating system.</li>
  <li>System central processing unit (CPU) time used by the process, as charged 
  by the operating system.</li>
</ul>

<h3><a name="Non-member-functions">Non-member functions</a></h3>

<pre>std::string format(nanosecond_type time,
                   short places = default_places,
                   const std::string&amp; format = default_format);</pre>
<blockquote>

<p><i>Effects:</i> If <code>places</code> is less than 0,&nbsp; it is set to <code>default_places</code>. If <code>places</code> is 
more than 9, it is set to 9. if the <code>format</code> 
argument is <code>empty()</code>, it is set to <code>
default_format</code>.</p>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of <code>'%w'</code> are replaced by <code>time</code> in seconds, 
shown to <code>places</code> decimal places.</p>

</blockquote>

<pre>std::string format(const cpu_times&amp; times,
                   short places = default_places,
                   const std::string&amp; format = default_format); </pre>
<blockquote>

<p><i>Effects:</i> If <code>places</code> is less than 0,&nbsp; it is set to <code>default_places</code>. If <code>places</code> is 
more than 9, it is set to 9. if the <code>format</code> 
argument is <code>empty()</code>, it is set to <code>
default_format</code>.</p>

<p><i>Returns:</i> A string that is a copy of <code>format</code>, except that any 
instances of the sequences shown below are replaced by the indicated value. 
Times are reported in seconds, 
shown to <code>places</code> decimal places. Percentage is reported to one 
decimal place. [<i>Note:</i> percentage may exceed 100% due to differences in 
how operating systems measure various times. <i>--end note</i>]</p>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="39%">
    <tr>
      <td width="25%"><b><i>Sequence</i></b></td>
      <td width="75%"><b><i>Replacement value</i></b></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%w</code></td>
      <td width="75%"><code>times.wall</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%u</code></td>
      <td width="75%"><code>times.user</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%s</code></td>
      <td width="75%"><code>times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%t</code></td>
      <td width="75%"><code>times.user + times.system</code></td>
    </tr>
    <tr>
      <td width="25%" align="center"><code>%p</code></td>
      <td width="75%">The percentage of <code>times.wall</code> represented by by <code>
      times.user + times.system</code></td>
    </tr>
  </table>
  </blockquote>

<h3><a name="Class-high_resolution_timer">Class <code>high_resolution_timer</code></a></h3>

<p> <code>high_resolution_timer_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<h3><a name="high_resolution_timer-synopsis"><code>high_resolution_timer</code> 
synopsis</a></h3>

<pre dir="ltr">    class <a name="high_resolution_timer">high_resolution_timer</a>
    {
    public:

      //  constructors, destructor
      high_resolution_timer() noexcept;

      // these 4 constructors enable automatic report() on destruction
      explicit high_resolution_timer(std::ostream&amp; os,
                                     short places = default_places,
                                     const std::string&amp; format = default_format);
      high_resolution_timer(std::ostream&amp; os, const std::string&amp; format);
      explicit high_resolution_timer(short places, const std::string&amp; format = default_format);
      explicit high_resolution_timer(const std::string&amp; format);

     ~high_resolution_timer();

      //  observers
      bool             is_stopped() const noexcept;
      nanosecond_type  elapsed() const noexcept;
      std::string      format(int places = default_places,
                              const std::string&amp; fmt = default_format) const;
      //  actions
      void             start() noexcept;
      nanosecond_type  stop() noexcept;
      void             resume() noexcept;
      void             report();

    private:
      nanosecond_type  m_time;         // <b><i>exposition only</i></b>
      bool             m_is_stopped;   // <b><i>exposition only</i></b>
      short            m_places;       // <b><i>exposition only</i></b> 
      std::ostream*    m_os;           // <b><i>exposition only</i></b>
      std::string      m_format;       // <b><i>exposition only</i></b>
    };</pre>
<p>Constructors with arguments enable automatic <code>report()</code> on 
destruction.</p>
<p>Constructors with arguments but without a <code>std::ostream&</code> argument assume
<code>std::cout</code>. An explicit default argument is not provided because it would require 
a high-cost include of <code>&lt;iostream&gt;</code>, even when the standard streams are not used.</p>
<h3><a name="high_resolution_timer-constructors"><code>high_resolution_timer</code> 
constructors</a>, destructor</h3>
<pre>high_resolution_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == 0;</pre>
  </blockquote>
</blockquote>
<pre>explicit high_resolution_timer(std::ostream&amp; os,
                               short places = default_places,
                               const std::string&amp; format = default_format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;os;
m_places == places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>high_resolution_timer(std::ostream&amp; os, const std::string&amp; format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;os;
m_places == default_places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>explicit high_resolution_timer(short places, const std::string&amp; format = default_format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;std::cout;
m_places == places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>explicit high_resolution_timer(const std::string&amp; format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;std::cout;
m_places == default_places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>~high_resolution_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (m_os &amp;&amp; !is_stopped())
{
  try
  {
    report();
  }
  catch (...)
  {
  }
}</pre>
  </blockquote>
</blockquote>
<h3><a name="high_resolution_timer-observers"><code>high_resolution_timer</code> 
observers</a></h3>
<pre>bool is_stopped() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> <code>m_is_stopped</code>.</p>
</blockquote>
<pre>nanosecond_type elapsed() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> If <code>is_stopped()</code>, <code>m_time</code>. 
  Otherwise, the difference between <code>m_time</code> and current wall-clock 
  time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>std::string format(int places = default_places,
                   const std::string&amp; fmt = default_format) const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>format(elapsed(), places, format)</code>.</p>
</blockquote>
<h3><a name="high_resolution_timer-actions"><code>high_resolution_timer</code> 
actions</a></h3>
<pre>void start() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>!is_stopped()</code> and <code>m_time</code> is 
set to the current wall-clock time.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>nanosecond_type stop() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>is_stopped()</code> and <code>m_time</code> is 
set to the difference between <code>m_time</code> and current wall-clock time.</p>

<p><i>Returns:</i> <code>m_time,</code> after the establishment of the <i>
Postconditions</i>.</p>

<p><i>Remarks:</i> Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>.</p>

</blockquote>
<pre>void resume() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (is_stopped())
{
  nanosecond_type current (m_time);
  start();
  m_time -= current;
}</pre>
  </blockquote>
</blockquote>
<pre>void report();</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (m_os)
{
  m_os &lt;&lt; timer::format(stop(),*m_os, m_places, m_format);
}</pre>
  </blockquote>
    <p>[<i>Note:</i> <code>stop()</code> is called because leaving the timer 
    running while doing I/O seems likely to produce misleading results. <i>--end 
    note</i>]</p>
</blockquote>
<h3><a name="Class-cpu_timer">Class <code>cpu_timer</code></a></h3>

<p> <code>cpu_timer</code> objects measure wall-clock elapsed time, process elapsed 
time charged to the user, and process elapsed time charged to the system.</p>

<p><i><b><a name="Current-time-values">Current time values</a></b></i> are 
obtained as follows: Current wall-clock time is obtained from the Boost.Chrono <code>
high_resolution_clock</code>. Current user and system time values are obtained 
from the appropriate operating system API functions such as <code>times()</code> 
on POSIX or <code>
GetProcessTimes()</code> on Windows.</p>

<h3 dir="ltr"> <code>cpu_timer</code> synopsis</h3>

<pre dir="ltr">    class <a name="cpu_timer">cpu_timer</a>
    {
    public:

      //  constructors, destructor
      cpu_timer() noexcept;

      // these 4 constructors enable automatic report() on destruction
      explicit cpu_timer(std::ostream&amp; os,
                         short places = default_places,
                         const std::string&amp; format = default_format);
      cpu_timer(std::ostream&amp; os, const std::string&amp; format);
      explicit cpu_timer(short places, const std::string&amp; format = default_format);
      explicit cpu_timer(const std::string&amp; format);

     ~cpu_timer() noexcept;

      //  observers
      bool              is_stopped() const noexcept;
      cpu_times         elapsed() const noexcept;
      std::string       format(const std::string& format = default_format,
                               int places = default_places) const;
      //  actions
      void              start() noexcept;
      const cpu_times&  stop() noexcept;
      void              resume() noexcept;
      void              report();

    private:
      cpu_times         m_times;          // <b><i>exposition only</i></b>
      bool              m_is_stopped;     // <b><i>exposition only</i></b>
    };</pre>
<h3><a name="cpu_timer-constructors"><code>cpu_timer</code> 
constructors</a>, destructor</h3>
<pre>cpu_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == 0;</pre>
  </blockquote>
</blockquote>
<pre>explicit cpu_timer(std::ostream&amp; os,
                   short places = default_places,
                   const std::string&amp; format = default_format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;os;
m_places == places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>cpu_timer(std::ostream&amp; os, const std::string&amp; format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;os;
m_places == default_places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>explicit cpu_timer(short places, const std::string&amp; format = default_format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;std::cout;
m_places == places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>explicit cpu_timer(const std::string&amp; format);</pre>
<blockquote>
<p><i>Effects:</i> <code>start()</code>.</p>
<p><i>Postconditions:</i></p>
  <blockquote>
    <pre>m_os == &amp;std::cout;
m_places == default_places;
m_format == format;</pre>
  </blockquote>
</blockquote>
<pre>~cpu_timer() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (m_os &amp;&amp; !is_stopped())
{
  try
  {
    report();
  }
  catch (...)
  {
  }
}</pre>
  </blockquote>
</blockquote>
<h3><a name="cpu_timer-observers"><code>cpu_timer</code> 
observers</a></h3>
<pre>bool is_stopped() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> <code>m_is_stopped</code>.</p>
</blockquote>
<pre>cpu_times elapsed() const noexcept;</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> If <code>is_stopped()</code>, <code>m_times</code>. 
  Otherwise, the difference between <code>m_times</code> values and 
  <a href="#Current-time-values">current time values</a>.</p>

</blockquote>
<pre>std::string format(const std::string&amp; format = default_format,
                   int places = default_places) const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>format(elapsed(), format, places)</code>.</p>
</blockquote>
<h3><a name="cpu_timer-actions"><code>cpu_timer</code> 
actions</a></h3>
<pre>void start() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>!is_stopped()</code> and <code>m_times</code> 
values are set to the <a href="#Current-time-values">current time values</a>.</p>

</blockquote>
<pre>cpu_times stop() noexcept;</pre>
<blockquote>

<p><i>Postconditions:</i> <code>is_stopped()</code> and <code>m_times</code> is 
set to the difference between <code>m_times</code> values and
<a href="#Current-time-values">current time values</a>.</p>

<p><i>Returns:</i> <code>m_times,</code> after the establishment of the <i>
Postconditions</i>.</p>

</blockquote>
<pre>void resume() noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (is_stopped())
{
  cpu_times current (m_times);
  start();
  m_times.wall -= current.wall;
  m_times.user -= current.user;
  m_times.system -= current.system;
}</pre>
  </blockquote>
</blockquote>
<pre>void report();</pre>
<blockquote>
  <p><i>Effects:</i> As if:</p>
  <blockquote>
    <pre>if (m_os)
{
  m_os &lt;&lt; timer::format(stop(),*m_os, m_places, m_format);
}</pre>
  </blockquote>
  <p>[<i>Note:</i> <code>stop()</code> is called because leaving the timer 
  running while doing I/O seems likely to produce misleading results. <i>--end 
  note</i>]</p>
</blockquote>

  <h2><a name="FAQ">FAQ</a></h2>

  <p>&nbsp;</p>

  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Rob Stewart contributed many corrections, comments, and suggestions. In 
  particular, he suggested the <code>resume()</code> and <code>format()</code> 
  functions, resulting in improved ease-of-use for several use cases.</p>

<hr>
<p><font size="2">Last revised:
<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->25 September, 2011<!--webbot bot="Timestamp" endspan i-checksum="39340" --></font></p>
<p><font size="2">© Copyright Beman Dawes, 2006, 2011</font></p>
<p><font size="2">Distributed under the Boost Software License, Version 1.0.  See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/ LICENSE_1_0.txt</a></font></p>

</body>

</html>